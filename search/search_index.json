{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pumas-AI Julia Workshop","text":"<p>This workshop is an introduction to the Julia programming language, covering the following topics:</p> <ul> <li>Variables and types:<ul> <li>Numeric variables and math operations</li> <li>Boolean variables</li> <li>Strings</li> <li>Containers</li> </ul> </li> <li>Syntax:<ul> <li>Control flow<ul> <li>Conditional statements</li> <li>Loops</li> </ul> </li> <li>Variable assignment</li> <li>Modules</li> <li>Macros</li> </ul> </li> <li>Functions:<ul> <li>Syntax</li> <li>Advanced topics:<ul> <li>Docstrings</li> <li>Default values</li> <li>Keyword arguments</li> <li>Anonymous functions </li> </ul> </li> <li>Multiple dispatch</li> </ul> </li> <li>Functional programming<ul> <li>Use the vectorized form of a function.</li> <li>Apply a function over an array with <code>map</code> and <code>foreach</code>.</li> <li>Collapse containers into a single value with <code>reduce</code> and <code>mapreduce</code>.</li> <li>Filter and count values based on boolean variables using <code>filter</code> and <code>count</code>.</li> <li>Compose and chain functions. </li> </ul> </li> </ul> <p>Prerequisites</p> <p>This workshop provides an introduction to the Julia programming language with a focus on functional programming.  Familiarity with programming concepts will be helpful but not required.</p>"},{"location":"#schedule","title":"Schedule","text":""},{"location":"#part-1-variables-and-types","title":"Part 1: variables and types","text":"Time (HH:MM) Activity Description 00:00 Setup Download files required for the workshop 00:05 Numeric variables and math Showcase <code>01-variables/01-numeric.jl</code> 00:10 Boolean variables Showcase <code>01-variables/02-booleans.jl</code> 00:15 Strings Showcase <code>01-variables/03-strings.jl</code> 00:20 Containers Showcase <code>01-variables/04-containers.jl</code>"},{"location":"#part-2-syntax","title":"Part 2: syntax","text":"Time (HH:MM) Activity Description 00:05 Conditional statements Showcase <code>02-syntax/01-conditionals.jl</code> 00:20 Loops Showcase <code>02-syntax/02-loops.jl</code> 00:30 Variable asignment Showcase <code>02-syntax/03-assignments.jl</code> 00:35 Modules Showcase <code>02-syntax/04-modules.jl</code> 00:40 Macros Showcase <code>02-syntax/05-macros.jl</code>"},{"location":"#part-3-functions","title":"Part 3: functions","text":"Time (HH:MM) Activity Description 00:10 Syntax Showcase <code>03-functions/01-syntax.jl</code> 00:30 Advanced topics Showcase <code>03-functions/02-advanced.jl</code> 00:35 Multiple dispatch Showcase <code>03-functions/03-dispatch.jl</code>"},{"location":"#part-4-functional-programming","title":"Part 4: functional programming","text":"Time (HH:MM) Activity Description 00:10 Apply functions over an array Showcase <code>04-functional_programming/01-apply.jl</code> 00:15 Collapse containers into a single value Showcase <code>04-functional_programming/02-reduce.jl</code> 00:20 Filter and count values Showcase <code>04-functional_programming/03-filter.jl</code> 00:30 Compose and chain functions Showcase <code>04-functional_programming/04-composition.jl</code>"},{"location":"#get-in-touch","title":"Get in touch","text":"<p>If you have any suggestions or want to get in touch with our education team, please send an email to training@pumas.ai.</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Juan Jos\u00e9 Gonz\u00e1lez Oneto - j.oneto@pumas.ai</li> </ul>"},{"location":"#license","title":"License","text":"<p>This content is licensed under Creative Commons Attribution-ShareAlike 4.0 International.</p> <p></p>"},{"location":"code_of_conduct/","title":"Code of Conduct for Pumas-AI Julia Workshop","text":"<p>At Pumas-AI we are committed to creating a friendly and respectful place for learning, teaching and contributing. All participants in our events and communications are expected to show respect and courtesy to others. To make clear what is expected, everyone participating in Pumas-AI activities is required to conform to the Code of Conduct.</p> <p>Pumas-AI is dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. As such, we do not tolerate behaviour that is disrespectful to our instructors or learners or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, veteran status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level.</p>"},{"location":"code_of_conduct/#expected-behaviour","title":"Expected Behaviour","text":"<p>All participants in our events and communications are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviours in all Pumas-AI events and platforms:</p> <ul> <li>Use welcoming and inclusive language</li> <li>Be respectful of different viewpoints and experiences</li> <li>Gracefully accept constructive criticism</li> <li>Focus on what is best for the community</li> <li>Show courtesy and respect towards other community members</li> </ul>"},{"location":"code_of_conduct/#unacceptable-behaviour","title":"Unacceptable Behaviour","text":"<p>Examples of unacceptable behaviour by participants at any Pumas-AI event/platform include:</p> <ul> <li>written or verbal comments which have the effect of excluding people on the basis of membership of any specific group</li> <li>causing someone to fear for their safety, such as through stalking, following, or intimidation</li> <li>violent threats or language directed against another person</li> <li>the display of sexual or violent images</li> <li>unwelcome sexual attention</li> <li>nonconsensual or unwelcome physical contact</li> <li>sustained disruption of talks, events or communications</li> <li>insults or put downs</li> <li>sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes</li> <li>excessive swearing</li> <li>incitement to violence, suicide, or self-harm</li> <li>continuing to initiate interaction (including photography or recording) with someone after being asked to stop</li> <li>publication of private communication without consent</li> </ul>"},{"location":"code_of_conduct/#consequences-of-unacceptable-behaviour","title":"Consequences of Unacceptable Behaviour","text":"<p>Participants who are asked to stop any inappropriate behaviour are expected to comply immediately. This applies to any Pumas-AI events and platforms, either online or in-person. If a participant engages in behaviour that violates this code of conduct, the organisers may warn the offender, ask them to leave the event or platform (without refund, if applicable), or engage with Pumas-AI representatives to investigate the Code of Conduct violation and impose appropriate sanctions.</p>"},{"location":"code_of_conduct/#get-in-touch","title":"Get in touch","text":"<p>If you have any suggestions or want to get in touch with our education team, please send an email to training@pumas.ai.</p>"},{"location":"code_of_conduct/#license","title":"License","text":"<p>This content is licensed under Creative Commons Attribution-ShareAlike 4.0 Internacional.</p> <p></p>"},{"location":"contribute/","title":"How to Contribute","text":"<p>If you want to contribute to this workshop, please open a pull request at <code>PumasAI-Labs/Julia-Workshop</code>.</p> <p>By submitting a pull request, you are in accordance that your contribution will be licensed under Creative Commons Attribution-ShareAlike 4.0 International.</p> <p>Once your pull request is approved and merged, you'll be acknowledged as one of the authors in the workshop site and GitHub repository.</p>"},{"location":"instructors/","title":"Instructor's Notes for Pumas-AI Julia Workshop","text":""},{"location":"instructors/#part-1-variables-and-types","title":"Part 1: variables and types","text":"<p>All scripts corresponding to this part of the workshop can be found in the <code>01-variables</code> folder. We suggest starting with <code>01-numeric.jl</code> and moving on according to the numbering system (e.g after <code>01-numeric.jl</code>, go through <code>02-booleans.jl</code>), but you could adjust this according to your needs. In any case, we suggest leaving <code>04-containers.jl</code> for the end, as going through the concepts on that script will probably be easier after covering the content on the other ones.</p> <p>When showcasing <code>01-numeric.jl</code>, start explaining that Julia has extensive support for numeric variables, but that most users will use and come across <code>Float</code>s and <code>Integer</code>s. Go over the definition of <code>Integer</code>s, what they mean and how variables are assigned in Julia. Make sure to mention the use of underscores (<code>_</code>) as a useful tool to define  large numbers. Next, go over <code>Float</code>s following a similar approach to the one used to explain integers. Mention that <code>Float</code>s are also known as <code>double</code>s in other programming languages. Show how you can create the same values as before,  but as <code>Float</code>s (e.g, <code>1</code> and <code>1.0</code>) and use this opportunity to explain the use of <code>typeof</code> to check a variable's type.  Here you can show how to define numbers in scientific notation. Lastly, go over all the math operations, mentioning the  PEMDAS order of operations, how to calculate square roots with <code>\\sqrt&lt;TAB&gt;</code>  and briefly showcasing rational and complex numbers.</p> <p>For <code>02-booleans.jl</code>, start by showing the possible comparisons between numbers (less than, greater than, etc.). After that, explain the use of <code>!</code> for negation, <code>||</code> for OR and <code>&amp;&amp;</code> for AND. Make sure to go over how these operators work if needed. There could be questions about using <code>|</code> and <code>&amp;</code> instead of <code>||</code> and <code>&amp;&amp;</code>. If that is the case, explain the difference between boolean operators (two operators) and bitwise operators (single operator). Next, go over the <code>true</code> and <code>false</code> types, using the examples to showcase how they work and further explain the use of the  operators. Mentioning that in Julia these types start with lower case could be useful if there are Python users in the audience. Lastly, show how boolean values can be used in math operations.</p> <p>When going over <code>03-strings.jl</code>, begin by showing how strings are created in Julia using double quotes. Mentioning that Julia doesn't support creating strings with single quotes is probably a good idea, specially if there are R or Python users in the  audience. Also, make sure to mention the use of triple quotes as an alternative to create longer strings spanning more than one line. For the next part, go over some of the string manipulations, starting with joining strings and showing the different methods on the script. Next, go over the use of <code>contains</code> and <code>occursin</code> for pattern matching and the formatting functions (e.g, <code>uppercase</code>).</p> <p>Lastly, cover <code>04-containers.jl</code>. Start by showing how <code>Vector</code>s are created using the examples to show that they can contain any type of variables. Next, go over matrices and the two different methods that could be used to create a matrix (line breaks and <code>;</code>). As an alternative, show the use of <code>reshape</code> to create a matrix from a <code>Vector</code>, and use this opportunity to discuss what Julia being column-major means. After that, show how indexing and slicing works for both <code>Vector</code>s and matrices. Lastly, go over dictionaries. Start by showing how to create them using <code>Tuple</code>s and the <code>Pair</code>s, and how to retrieve the values by indexing using the keys.</p>"},{"location":"instructors/#part-2-syntax","title":"Part 2: syntax","text":"<p>All scripts corresponding to this part of the workshop can be found in the <code>02-syntax</code> folder. In this case, it is recommended to start with <code>01-conditionals.jl</code> and follow the numbering scheme, as later scripts (e.g. <code>02-loops.jl</code>) use concepts from the previous ones.</p> <p>When covering the content from <code>01-conditionals.jl</code>, start by providing a brief description of what conditional statements are and how they allow creating more complex programs by altering the flow of execution. Once everyone is comfortable with that idea, show how they are created in Julia through the <code>if</code>, <code>elseif</code> and <code>else</code> keywords. Make sure to mention that Julia requires the keyword <code>end</code> to be present at the end, as this could be confusing for users coming from other programming languages. After that, go over the example that uses two <code>elseif</code> and doesn't have an <code>else</code> case, and use it to explain that conditional statements can be created in many different ways and that only <code>if</code> is required to create one. Lastly, explain how the ternary operator (<code>?:</code>) works and how it can be useful to write <code>if-else</code> statements concisely.</p> <p>Next, go over <code>02-loops.jl</code>. Once again, start by explaining that they are used to alter a program's flow of execution through the repeated evaluation of an expression. Start by explaining <code>for</code> loops with the simple example that prints all numbers from 1 to 10. After going over this example, make sure to mention how using the <code>for</code> loop saved a lot of work for this task. Two good ways to convey this idea could be showing how that would be done without a loop (manually write <code>println(1)</code>, <code>println(2)</code>, etc.) or changing the range to be much larger (<code>e.g. numbers = 1:1000</code>) so that the hard-coded solution is no longer feasible. After that, go over the example that combines a <code>for</code> loop and a conditional statement to showcase this common pattern.</p> <p>The next part of <code>02-loops.jl</code> covers the use of <code>while</code> loops. Start by explaining that <code>while</code> loops are different to <code>for</code> loops in that their iterations depend on the value of a boolean variable, instead of a collection or an iterable. Use the same example of printing all numbers from 1 to 10, focusing on how the <code>counter</code> changes until it reaches 11 and provide a brief explanation on why <code>global</code> is used when updating it's value. Next, go over the example of finding a name inside of a list. Use this example to explain why <code>while</code> loops are convenient when it is not necessary to iterate over an entire collection and how this example could be extended for a case where there are many more names in the list. After that, show how a similar result can be obtained with a <code>for</code> loop, a conditional statement and the <code>break</code> keyword. This example is also a good opportunity to discuss one of the main disadvantages of <code>while</code> loops, which is that you can easily create infinite loops. Going back to the previous examples might be required to show how an infinite loop can be created (e.g. the name you are looking for is not in the list or you forget to update the counter). Lastly, go over array comprehensions and how they can be used to create arrays with loops.</p> <p>After that, cover the content on <code>03-assignments.jl</code>. This script goes over different topics regarding variable assignments, starting with the use of compound expressions. Show the different ways in which compound expressions can be created, but mention that using <code>begin..end</code> with multiple lines is probably the most common and readable syntax. The next topic is variable scopes. Show how <code>global</code> variables can be accessed everywhere and explain with greater detail why <code>global</code> is used inside <code>while</code> loops. Next, showcase the use of <code>local</code> and how local variables are only accessible where they are created (inside the loop, in the example). After that, go over the use of <code>const</code> to create variables whose values should not change. Use the examples to show that trying to change the value returns an error if the new value is of a different <code>Type</code>, but that you only get a warning if the new value has  the same <code>Type</code> as the original. Finally, explain the variable naming conventions in Julia with an emphasis on how variables and functions are named in  a different way to <code>Type</code>s and <code>Module</code>s.</p> <p>For <code>04-modules.jl</code>, start by going over the concept of a software <code>Module</code>/package/library as a tool to access other people's code. Go over how packages are imported with the <code>using</code> keyword by showing how to import <code>Pumas</code> and <code>Statistics</code>. Show that we have access to the <code>mean</code> function after importing <code>Statistics</code>. Mention that multiple packages can be imported in a single line, but explain that this syntax quickly becomes difficult to read and that importing packages in different lines is preferred. Also, show how only certain parts of the package can be loaded with the <code>Package: func</code> syntax. After  that, show the use of <code>import</code> and explain how it is different from <code>using</code>.</p> <p>Lastly, go over <code>05-macros.jl</code>. Start by mentioning that the purpose of this lesson is to show how macros are used, and that creating macros and using Julia's metaprogramming tools is an advanced topic that will not be covered in the workshop. Curious attendees can be redirected to Julia's documentation section on metaprogramming, this workshop on metaprogramming from JuliaCon  2021 or other resources you might consider relevant.</p> <p>First, show that macros start with <code>@</code> and quickly go over the examples. Next, show the two ways in which macros can be called: using spaces or  parenthesis (as in a function). The <code>@time</code> and <code>@doc</code> macros are used in the examples, so it is a good idea to briefly talk about what those macros do.  Lastly, show how <code>@macroexpand</code> can be used to see what a macro is doing under the hood. </p>"},{"location":"instructors/#part-3-functions","title":"Part 3: functions","text":"<p>The code examples for this section of the workshop can be found in the <code>03-functions</code> folder.</p> <p>Start by going over <code>01-syntax.jl</code> as this script will cover the basics of defining and calling functions. First, show the standard way of creating functions with the <code>function</code> keyword, and then show how a function can be called once it has been defined. Use the examples to show that a function can have a single argument, multiple arguments, or no arguments at all. Next, go over the compact assignment form to create functions, how that can be convenient for small or simple functions and how it allows creating functions in a very similar way to math. Lastly, go over the <code>return</code> keyword, how it can be used to return multiple values and how those values can be retrieved after a function call.</p> <p>Next, cover the contents of <code>02-advanced.jl</code>. This file contains code examples about a variety of advanced topics regarding the use of functions in Julia. The first topic is documentation. Show how you can add docstrings on top of a function's definition and how you can then access that documentation in the REPL by typing <code>?function_name</code>. If there are users that know how to write Markdown, mention that docstrings are interpreted as Markdown when displayed in the REPL. After that, go over argument and return <code>Type</code>s. Start by explaining how you can specify the accepted argument <code>Type</code>s by showing the examples that work and the ones that produce errors. Once that is clear, go over specifying the return <code>Type</code>, which should be a natural extension of what was shown before.</p> <p>The next advanced topic is default values for arguments. Go over the example to show how the syntax and make sure to explain how defining default values could be useful. It is probably important to mention that positional arguments with default values should always be left for the end (e.g <code>f(x, y=2)</code> instead of <code>f(y=2, x)</code>). Next, cover the use of keyword arguments. Start by explaining that keyword arguments are different from positional arguments in that they are identified through their names, not their positions. Then, go over the examples to show how they are used,and make sure to mention that it is a good practice to separate keyword arguments from positional arguments with a semicolon (<code>;</code>). It might be useful to mention that many packages use keyword arguments, specially for functions that have many arguments, which are particularly common in plotting packages such as <code>CairoMakie</code> or <code>AlgebraOfGraphics</code>.</p> <p>Lastly, go over anonymous functions. Use the example to show how they can be convenient in some cases. Examples using functions like <code>map</code>, <code>foreach</code> or <code>filter</code> could be useful, but the use of these functions will only be covered in detail until the next part of the workshop.</p> <p>The last script for this part of the workshop is <code>03-dispatch.jl</code>. This is intended to be a brief introduction to  multiple dispatch in Julia. Start by showing again how argument <code>Type</code>s can be specified in a function. This should be brief as this topic was covered before. Next, use the code example to explain that sometimes it could be useful to have one function that behaves differently depending on the arguments that are passed to it. Show how you can \"define the function again\" with different argument <code>Type</code>s and how this creates another method for that function. To finish, go over the <code>methods</code> function, which allows you to see a list of the available methods for a function. Show how to use it with both the function from the example and a function from Julia's standard library.</p>"},{"location":"instructors/#part-4-functional-programming","title":"Part 4: functional programming","text":"<p>The files for this part of the workshop are located in the <code>04-functional_programming</code> folder.</p> <p>Start by going over the content on <code>01-apply.jl</code>. This script contains examples on the use of vectorized functions, <code>map</code> and <code>foreach</code> to apply a function to all elements in an array. To begin, use the example to show how the  vectorized version of a function can be used to apply a function to a collection in a concise syntax. Make sure to mention that this behavior is available for in any Julia function. Using an example from a function that was not defined in the script might be useful for this. Also, cover the use of the <code>@.</code> macro as a convenient tool to write expressions that require using the vectorized version of many functions.</p> <p>Next, go over the use of the <code>map</code> function, which allows getting the same results as before by specifying the function and the collection as it's arguments. Explain the examples and make special emphasis on the use of <code>map</code> with anonymous functions, since this is a common use case for the function. After that, explain how the <code>foreach</code> function works. Here, is it very important to make sure that users understand the difference between <code>map</code> and <code>foreach</code>.</p> <p>After that, move on to the <code>02-reduce.jl</code> script. This part of the lesson is focused on the use of <code>reduce</code> and <code>mapreduce</code> to collapse containers into a single value. Start by showing the simple examples involving <code>+</code> and <code>*</code> and then go over the more complex one involving a custom function. Make sure to provide a detailed explanation on how this function is created as it could be confusing at first, but note that <code>reduce</code> is often used with <code>+</code> and <code>*</code>. Users might be curious as to why it was necessary to provide an initial value in the example for the custom function and not before. If that is the case, you can answer that the <code>init</code> keyword argument is required for all functions except <code>+</code>, <code>*</code>, <code>min</code> and <code>max</code>. Next, cover the common use pattern of <code>reduce</code> + <code>map</code> and mention that the same results can be achieved with <code>mapreduce</code>, but with improved performance. You can find more information about this in  <code>mapreduce</code>'s docstring.</p> <p>The next script that you should go over is <code>03-filter.jl</code>. The code examples in this file focus on the use of the <code>filter</code> function, which allows retrieving the elements of an array that satisfy a given condition. Go over the syntax, highlighting the fact that it is the same as <code>map</code>, <code>foreach</code> and <code>reduce</code>. You might need to spend extra time in the example about removing <code>missing</code> values. In particular, make sure to explain why it is necessary to use the <code>ismissing</code> function. Lastly, show the use of the <code>count</code> function as an alternative to <code>filter</code> when you are only interested in knowing how many elements satisfy a condition (as opposed to knowing which elements satisfy the condition).</p> <p>Finally, go over the contents on <code>04-composition.jl</code>. This is a brief introduction to composing and chaining function calls. Start by going over the  composition operator (<code>\u2218</code>). Show that this is an alternative to calling multiple functions inside each other (e.g <code>func1(func2(func3(args)))</code>) and explain how it allows combining simple functions to create a more complicated one. Also, make sure to showcase how you can define a new function from the composition of multiple functions through the assignment syntax (<code>new_function = func1 \u2218 func2 \u2218 func3</code>) and that you can define the function and call it in one go (<code>(func1 \u2218 func2 \u2218 func3)(args)</code>). It is likely that users won't know how to type <code>\u2218</code>, so make sure to mention that it is created with <code>\\circ&lt;TAB&gt;</code>.</p> <p>The last topic for this lesson is function chaining through the pipe operator (<code>|&gt;</code>). Show how it can be used to get the same results as with function composition, but with a different syntax. Make sure to mention that parenthesis are required when using anonymous functions and that the pipe operator can be used in a vectorized version (<code>.|&gt;</code>).</p>"},{"location":"instructors/#get-in-touch","title":"Get in touch","text":"<p>If you have any suggestions or want to get in touch with our education team, please send an email to training@pumas.ai.</p>"},{"location":"instructors/#license","title":"License","text":"<p>This content is licensed under Creative Commons Attribution-ShareAlike 4.0 International.</p> <p></p>"},{"location":"reference/","title":"Reference Sheets for Pumas-AI Julia Workshop","text":""},{"location":"reference/#key-points","title":"Key Points","text":""},{"location":"reference/#part-1-variables-and-types","title":"Part 1: variables and types","text":"<ul> <li>Although there are more numeric types, <code>Integer</code>s and <code>Float</code>s are the most common ones.</li> <li><code>Float</code>s are also known as <code>double</code>s in other programming languages.</li> <li>Underscores (<code>_</code>) could be helpful to define large numbers. For example,  <code>1000000</code> could be written as <code>1_000_000</code>.</li> <li><code>typeof</code> can be used to check a variable's type.</li> <li>Julia supports defining numbers in scientific notation (e.g <code>1e3</code> is <code>1*10^3</code>).</li> <li>Square roots can be calculated using <code>sqrt</code> or <code>\u221a</code>, written as <code>\\sqrt&lt;TAB&gt;.</code></li> <li>Boolean variables can only take two values: <code>true</code> or <code>false</code>.</li> <li>When used in a math context, <code>true</code> is interpreted as <code>1</code> and <code>false</code> as <code>0</code>.</li> <li><code>String</code>s are defined using double or triple quotes in Julia. Single quotes are reserved for <code>Char</code>s and cannot be used to define <code>String</code>s.</li> <li>There are many ways to concatenate <code>String</code>s:<ul> <li>Using the <code>string</code> function.</li> <li>Using <code>*</code>.</li> <li>Using <code>$</code> for interpolations.</li> </ul> </li> <li><code>String</code> interpolations are very poweful and can contain complex expressions.</li> <li>Julia has extensive support for pattern matching, including the use of regular expressions.</li> <li>There are convenience functions such as <code>uppercase</code> or <code>lowercase</code> that allow formatting <code>String</code>s.</li> <li><code>Vector</code>s are one-dimensional structures that can contain any type of variable.</li> <li>Matrices can be defined using line breaks, <code>;</code> or through <code>reshape</code>.</li> <li>Single values can be retrieved through indexing, while slicing allows retrieving multiple values.</li> <li>Dictionaries store a collection of (key, value) pairs, where values are retrieved by indexing with the keys.</li> </ul>"},{"location":"reference/#part-2-syntax","title":"Part 2: syntax","text":"<ul> <li>Conditional statements are created with the <code>if</code>, <code>elseif</code> and <code>else</code> keywords.</li> <li>You can add as many <code>elseif</code> as needed, and don't need to add <code>else</code>. You can also have a conditional statement that only includes <code>if</code>.</li> <li>The ternary operator (<code>?:</code>) provides a convenient way to create an <code>if-else</code>  statement in a single line.</li> <li>There are two types of loops, which are created with <code>for</code> and <code>while</code> keywords.</li> <li><code>for</code> loops are useful when you need to iterate over all elements and <code>while</code> loops are more suited to when you only want to loop as long as certain conditions are met.</li> <li>You can emulate the behavior of a <code>while</code> loop in a <code>for</code> loop by using a conditional statement and <code>break</code>.</li> <li>Conditional statements and loops should always have the <code>end</code> keyword at the end.</li> <li>Array comprehensions provide a powerful way to create an array using <code>for</code> loops.</li> <li>Compound expressions allow creating blocks of code through the <code>begin...end</code> syntax.</li> <li><code>global</code> variables are available everywhere, while <code>local</code> variables are only available in the context where they are created.</li> <li>Constant variables can be defined using the <code>const</code> keyword before the variable definition.</li> <li>Variables should always be named with lowercase letters, and spaces should be replaced with underscores (<code>_</code>).</li> <li><code>Module</code>s and <code>Types</code>' names start with a capital letter and use  CamelCase instead of spaces.</li> <li>Macros start with <code>@</code>.</li> <li>Macros can be called through spaces or with parenthesis (as in functions).</li> <li><code>@macroexpand</code> can be used to examine what a macro is doing under the hood.</li> </ul>"},{"location":"reference/#part-3-functions","title":"Part 3: functions","text":"<ul> <li>Complex functions can be created with the <code>function</code> keyword, while simpler ones can be  more conveniently defined using the compact assignment form (e.g <code>f(x) = x^2</code>).</li> <li>When a function doesn't have a return value, it is a good practice to place <code>return end</code> at the end of the function definition.</li> <li>You can return multiple values by separating them with commas (e.g <code>return value1, value2, ...</code>). Multiple return values can then be retrieved by indexing the resulting <code>Tuple</code> or by separating  the variables where they will be stored with commas (e.g <code>value1, value2 = f(x)</code> with <code>f(x)</code> having <code>return value1, value2</code> at the end).</li> <li>You can add documentation to a function by adding docstrings on top of the function definition. These strings are interpreted as Markdown, and can be accessed from the Julia REPL by typing <code>?function_name</code>.</li> <li>You can constrain the variable <code>Type</code>s that are accepted as input and the variable <code>Type</code> returned by the function using <code>::</code>. For example, in <code>product(x::Int, y::Int)::Float64 = x*y</code>, the two arguments  are restricted to be of type <code>Int</code> and the return value to be a <code>Float64</code>).</li> <li>You can set default values for a function's arguments by using the assignment syntax inside  of the function's definition. For instance, <code>f(x = 2) = 2x</code> will make <code>2</code> be the default value for <code>x</code>.</li> <li>Keyword arguments are separated from positional arguments with a semicolon (<code>;</code>). The order in which keyword arguments are passed to the function doesn't matter. Instead, the names are used to identify which value is assigned to which argument.</li> <li>Anonymous functions can be used when the name of the function is not relevant. </li> <li>Multiple dispatch allows specifying a different behavior for functions depending on the arguments that are passed to them. Each one of those definitions are known as methods.</li> <li>You can check the available methods for a function with the <code>methods</code> function (e.g <code>methods(println)</code>).</li> </ul>"},{"location":"reference/#part-4-functional-programming","title":"Part 4: functional programming","text":"<ul> <li>The dot syntax (<code>f.(x)</code>) allows you to use the vectorized version of a function.</li> <li>You can apply a function on each element of an array using the <code>map</code> function.</li> <li>You can execute a function on each element of an array using the <code>foreach</code> function. <code>foreach</code>  differs from <code>map</code> in that it does not return an array with the results, so it should only  be used when the return values of the function being applied are not needed.</li> <li>The <code>reduce</code> function allows collapsing the elements of an array using a function. </li> <li>A common use of <code>reduce</code> consists on creating an array with <code>map</code> and then passing it to <code>reduce</code> to obtain a single value. Instead of doing this, it is recommended to use <code>mapreduce</code>, which offers this functionality and has better performance.</li> <li>You can pick the elements that satisfy a given condition in an array using the <code>filter</code> function.</li> <li>If you want to check if a variable is <code>missing</code>, you should use the function <code>ismissing</code> instead of a comparison such as <code>var == missing</code>, which will always return <code>missing</code>, regardless of <code>var</code>'s <code>Type</code>.</li> <li>If you are only interested in knowing how many elements satisfy a given condition, you can use the  <code>count</code> function.</li> <li>Functions can be combined using the composition operator (<code>\u2218</code>).</li> <li>Consecutive function calls can be chained using the pipe operator (<code>|&gt;</code>).</li> </ul>"},{"location":"reference/#summary-of-basic-commands","title":"Summary of Basic Commands","text":""},{"location":"reference/#part-1-variables-and-types_1","title":"Part 1: variables and types","text":"Action Command Observations Integer type <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code> (<code>Int</code>) and <code>Int128</code> Notation is <code>IntX</code>, where <code>X</code> denotes the number of bits used to represent the number Floating-point number types <code>Float16</code>, <code>Float32</code> and <code>Float64</code> Notation is <code>FloatX</code>, following the same logic as <code>IntX</code> (see previous row) Boolean type <code>Bool</code> Can be <code>true</code> or <code>false</code> String type <code>String</code> Shouldn't be confused with the function <code>string</code> Vector type <code>Vector{type}</code> If a vector contains <code>Float64</code>s it would be <code>Vector{Float64}</code> or if contains multiple types it would be <code>Vector{Any}</code> Matrix type <code>Matrix{type}</code> Follows the same syntax as <code>Vector</code>s (see previous row) Dictionary type <code>Dict{key_type, value_type}</code> If a dictionary has <code>String</code> keys pointing to <code>Float64</code> values, it would be <code>Dict{String, Float64}</code> Check a variable's type <code>typeof</code> Used as <code>typeof(var)</code> Calculate a square root <code>sqrt</code> or <code>\u221a</code> Returns the square root of a number Negation <code>!</code> Negates a boolean expression OR operator <code>||</code> Returns <code>true</code> if at least one of the expressions is <code>true</code> AND operator <code>&amp;&amp;</code> Returns <code>true</code> if all the expressions are <code>true</code> String concatenation <code>string</code> and <code>*</code> <code>string(str1, str2, str3)</code> and <code>str1</code> * <code>str2</code> * <code>str3</code> have the same effect String interpolation <code>$</code> Used as <code>$(expression)</code> Pattern matching <code>contains</code> and <code>occursin</code> Used as <code>contains(haystack, needle)</code> and <code>occursin(needle, haystack)</code> Pattern matching (beginning) <code>startswith</code> Check whether a <code>String</code> begins with a given sequence Pattern matching (ending) <code>endswith</code> Check whether a <code>String</code> ends with a given sequence Return a string with all capital letters <code>uppercase</code> Return a string with all lower case letters <code>lowercase</code> Return a string in title case <code>titlecase</code> Replace a part of a string <code>replace</code> Used as <code>replace(str, original_part =&gt; new_part, ...)</code> Reshape a <code>Vector</code> <code>reshape</code> Used as <code>reshape(vector, new_shape)</code>, where <code>new_shape</code> could be <code>(3, 3)</code> to create a 3x3 matrix (if <code>vector</code> contains the appropriate number of elements) Indexing or slicing <code>vector[1]</code>, <code>vector[1:10]</code>, <code>matrix[1, 2]</code>, <code>matrix[1:3, 2:4]</code> Indexing returns a single value, while slicing returns multiple values"},{"location":"reference/#part-2-syntax_1","title":"Part 2: syntax","text":"Action Command Observations Create a conditional statement <code>if</code>, <code>elseif</code>, <code>else</code> Should always contain <code>if</code>, but <code>elseif</code> and <code>else</code> are optional Create a one line <code>if-else</code> conditional statement <code>&lt;boolean&gt; ? &lt;run if true&gt; : &lt;run if false&gt;</code> Known as ternary operator Create a <code>for</code> loop <code>for</code> Iterates over all elements Create a <code>while</code> loop <code>while</code> Iterates as long as a boolean expression is <code>true</code> Exit a loop <code>break</code> Create an array with a <code>for</code> loop <code>[&lt;expression involving i&gt; for i in collection]</code> Known as array comprehensions Create a code block <code>begin...end</code> Define a global variable <code>global</code> Used as <code>global var = var_value</code> Define a local variable <code>local</code> Used as <code>local var = var_value</code> Define a constant variable <code>const</code> Used as <code>const var = var_value</code> Import a module <code>using</code> or <code>import</code> <code>using</code> makes the content from the package directly available, while import requires <code>Package.func</code> to use it Macro call <code>@macro arg</code> or <code>@macro(arg)</code> See what a macro is doing under the hood <code>@macroexpand &lt;macro call&gt;</code>"},{"location":"reference/#part-3-functions_1","title":"Part 3: functions","text":"Action Command Observations Create a function (multiple lines syntax) <code>function name(args)</code> Used for long and complex functions Create a function (compact assignment form) <code>name(args) = &lt;expression&gt;</code> Used for short and simple functions. Similar to how functions are defined in math Create a function (anonymous) <code>(arg1, arg2, ...) -&gt; &lt;expression&gt;</code> Used when the function's name is not relevant Access a function's documentation from the REPL <code>?function_name</code> Docstrings are interpreted as Markdown Specify <code>Type</code>s of a function's arguments <code>f(x::&lt;type for x&gt;, y::&lt;type for y&gt;, ...) = ...</code> Specify the <code>Type</code> of a function's return <code>f(x, y)::&lt;type for return&gt; = ...</code> Define default values for an argument <code>f(x=&lt;default for x&gt;, y=&lt;default for y&gt;) = ...</code> Default values for positional arguments should be left for the end (e.g <code>f(x, y=2)</code> instead of <code>f(y=2, x)</code>, which will throw an error. Define keyword arguments for a function <code>f(&lt;positional args&gt;; &lt;keyword args&gt;) = ...</code> Keyword arguments are separated from positional arguments with a semicolon (<code>;</code>) Check the available methods for a function <code>methods(function)</code>"},{"location":"reference/#part-4-functional-programming_1","title":"Part 4: functional programming","text":"Action Command Observations Call the vectorized form of a function <code>f.(x)</code> Returns the result of evaluating <code>f</code> on each element of array <code>x</code> Apply a function on each element of an array <code>map</code> Used as <code>map(function, array)</code> Run a function on each element of an array <code>foreach</code> Similar to <code>map</code>, but doesn't return an array (just runs the function) Collapse all elements of an array into a single value using a function <code>reduce</code> Used as <code>reduce(reducing_function, array)</code> Create an array with <code>map</code> and then collapse it with <code>reduce</code> <code>mapreduce</code> Equivalent to <code>reduce(reducing_function, &lt;map call&gt;)</code>, but more efficient Get the elements that satisfy a given condition from an array <code>filter</code> Used as <code>filter(&lt;function returning boolean&gt;, array)</code> Check if a variable is missing <code>ismissing</code> Should be used instead of <code>var == missing</code>, which doesn't work Count how many elements satisfy a given condition in an array <code>count</code> Used in the same way as <code>filter</code> Compose functions <code>(function3 \u2218 function2 \u2218 function1)(arg)</code> <code>\u2218</code> is created with <code>\\circ&lt;TAB&gt;</code> Chain function calls <code>arg |&gt; function1 |&gt; function2 |&gt; function3</code> <code>|&gt;</code> can be vectorized as <code>.|&gt;</code>"},{"location":"reference/#glossary","title":"Glossary","text":""},{"location":"reference/#part-1-variables-and-types_2","title":"Part 1: variables and types","text":"PEMDAS <p>Short for Parenthesis, Exponents, Multiplication, Division, Addition and Substraction, which is the order in which mathematical operations are computed in Julia.</p> Scientific notation <p>Method for expressing numbers in decimal form (e.g 1200 would be 1.2x10\u00b3), commonly used in science, mathematics and engineering.</p> Boolean <p><code>Type</code> of variable that can only take two values: <code>true</code> or <code>false</code>.</p> Dictionary <p><code>Type</code> of variables that stores a collection of (key, value) pairs.</p>"},{"location":"reference/#part-2-syntax_2","title":"Part 2: syntax","text":"Conditional statement <p>Expression that allows controlling a program's flow of execution based on the value of a boolean expression.</p> Loops <p>Tool that allows controlling a program's flow of execution through the repeated evaluation of an expression.</p> Camel Case <p>Writing style where spaces are replaced by capital letters (e.g Camel case becomes CamelCase). <code>Module</code>s and  <code>Type</code>s are named using this style in Julia.</p> Macros <p>Special tool for metaprogramming in Julia.</p>"},{"location":"reference/#part-3-functions_2","title":"Part 3: functions","text":"Function <p>Julia object that maps a series of argument values to a return value.</p> Anonymous function <p>A function that is created without specifying a name.</p> Multiple dispatch <p>Feature in Julia that allows a function to behave differently based on the <code>Type</code>s of the arguments passed to it.</p>"},{"location":"reference/#part-4-functional-programming_2","title":"Part 4: functional programming","text":"Functional programming <p>Programming strategy that relies on creating and combining functions. </p> Vectorized function <p>Form of a function that allows applying it to all elements of a vector (e.g  <code>f([x1, x2, x3]) = [f(x1), f(x2), f(x3)]</code>)</p> Function composition <p>Combining two or more functions to create a new one that chains them together.  For example, composing functions the <code>f(x)</code> and <code>g(x)</code> (<code>f \u2218 g</code>) creates a new function defined as <code>f(g(x))</code>.</p>"},{"location":"reference/#get-in-touch","title":"Get in touch","text":"<p>If you have any suggestions or want to get in touch with our education team, please send an email to training@pumas.ai.</p>"},{"location":"reference/#license","title":"License","text":"<p>This content is licensed under Creative Commons Attribution-ShareAlike 4.0 International.</p> <p></p>"},{"location":"waiver/","title":"Waiver of Liability for Pumas-AI Julia Workshop","text":"<p>By using the content provided by Pumas-AI, you agree to the following:</p> <ol> <li>You acknowledge that Pumas-AI has provided you with access to certain content (the \"Content\"),    including but not limited to software, documentation, images, videos, and other materials.</li> <li>You understand and agree that the Content is provided \"as is,\" without warranty of any kind,    either express or implied, including but not limited to the implied warranties of merchantability    and fitness for a particular purpose.</li> <li>You acknowledge that Pumas-AI is not responsible for how you use the Content,    and that Pumas-AI shall not be liable for any damages arising from your use of the Content,    including but not limited to direct, indirect, incidental, special, consequential, or punitive damages,    whether in an action of contract, negligence, or other tortious action,    even if Pumas-AI has been advised of the possibility of such damages.</li> <li>You agree to indemnify, defend, and hold harmless Pumas-AI, its officers, directors, employees, agents,    and affiliates from and against any and all claims, damages, losses, liabilities,    and expenses (including reasonable attorneys' fees) arising from your use of the Content.</li> <li>You acknowledge that this Waiver of Liability is a legally binding agreement between you and Pumas-AI,    and that it governs your use of the Content.    If you do not agree to the terms of this Waiver of Liability, you must immediately cease using the Content.</li> </ol>"},{"location":"waiver/#get-in-touch","title":"Get in touch","text":"<p>If you have any suggestions or want to get in touch with our education team, please send an email to training@pumas.ai.</p>"},{"location":"waiver/#license","title":"License","text":"<p>This content is licensed under Creative Commons Attribution-ShareAlike 4.0 International.</p> <p></p>"}]}